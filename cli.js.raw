event: message
data: {"jsonrpc":"2.0","id":"cli1","result":{"content":[{"type":"text","text":"[task:ee2b71378fdb] #!/usr/bin/env node\n\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commander_1 = require(\"commander\");\nconst fs = __importStar(require(\"fs\"));\nconst path = __importStar(require(\"path\"));\nconst utils_1 = require(\"./scripts/utils\");\nconst browser_config_1 = require(\"./scripts/browser-config\");\nconst doctor_1 = require(\"./scripts/doctor\");\nconst report_1 = require(\"./scripts/report\");\ncommander_1.program\n    .version(require('../package.json').version)\n    .description('Mcp Chrome Bridge - Local service for communicating with Chrome extension');\n// Register Native Messaging host\ncommander_1.program\n    .command('register')\n    .description('Register Native Messaging host')\n    .option('-f, --force', 'Force re-registration')\n    .option('-s, --system', 'Use system-level installation (requires administrator/sudo privileges)')\n    .option('-b, --browser <browser>', 'Register for specific browser (chrome, chromium, or all)')\n    .option('-d, --detect', 'Auto-detect installed browsers')\n    .action(async (options) => {\n    try {\n        // Write Node.js path for run_host scripts\n        (0, utils_1.writeNodePathFile)(__dirname);\n        // Determine which browsers to register\n        let targetBrowsers;\n        if (options.browser) {\n            if (options.browser.toLowerCase() === 'all') {\n                targetBrowsers = [browser_config_1.BrowserType.CHROME, browser_config_1.BrowserType.CHROMIUM];\n                console.log((0, utils_1.colorText)('Registering for all supported browsers...', 'blue'));\n            }\n            else {\n                const browserType = (0, browser_config_1.parseBrowserType)(options.browser);\n                if (!browserType) {\n                    console.error((0, utils_1.colorText)(`Invalid browser: ${options.browser}. Use 'chrome', 'chromium', or 'all'`, 'red'));\n                    process.exit(1);\n                }\n                targetBrowsers = [browserType];\n            }\n        }\n        else if (options.detect) {\n            targetBrowsers = (0, browser_config_1.detectInstalledBrowsers)();\n            if (targetBrowsers.length === 0) {\n                console.log((0, utils_1.colorText)('No supported browsers detected, will register for Chrome and Chromium', 'yellow'));\n                targetBrowsers = undefined; // Will use default behavior\n            }\n        }\n        // If neither option specified, tryRegisterUserLevelHost will detect browsers\n        // Detect if running with root/administrator privileges\n        const isRoot = process.getuid && process.getuid() === 0; // Unix/Linux/Mac\n        let isAdmin = false;\n        if (process.platform === 'win32') {\n            try {\n                isAdmin = require('is-admin')(); // Windows requires additional package\n            }\n            catch (error) {\n                console.warn((0, utils_1.colorText)('Warning: Unable to detect administrator privileges on Windows', 'yellow'));\n                isAdmin = false;\n            }\n        }\n        const hasElevatedPermissions = isRoot || isAdmin;\n        // If --system option is specified or running with root/administrator privileges\n        if (options.system || hasElevatedPermissions) {\n            // TODO: Update registerWithElevatedPermissions to support multiple browsers\n            await (0, utils_1.registerWithElevatedPermissions)();\n            console.log((0, utils_1.colorText)('System-level Native Messaging host registered successfully!', 'green'));\n            console.log((0, utils_1.colorText)('You can now use connectNative in Chrome extension to connect to this service.', 'blue'));\n        }\n        else {\n            // Regular user-level installation\n            console.log((0, utils_1.colorText)('Registering user-level Native Messaging host...', 'blue'));\n            const success = await (0, utils_1.tryRegisterUserLevelHost)(targetBrowsers);\n            if (success) {\n                console.log((0, utils_1.colorText)('Native Messaging host registered successfully!', 'green'));\n                console.log((0, utils_1.colorText)('You can now use connectNative in Chrome extension to connect to this service.', 'blue'));\n            }\n            else {\n                console.log((0, utils_1.colorText)('User-level registration failed, please try the following methods:', 'yellow'));\n                console.log((0, utils_1.colorText)('  1. sudo mcp-chrome-bridge register', 'yellow'));\n                console.log((0, utils_1.colorText)('  2. mcp-chrome-bridge register --system', 'yellow'));\n                process.exit(1);\n            }\n        }\n    }\n    catch (error) {\n        console.error((0, utils_1.colorText)(`Registration failed: ${error.message}`, 'red'));\n        process.exit(1);\n    }\n});\n// Fix execution permissions\ncommander_1.program\n    .command('fix-permissions')\n    .description('Fix execution permissions for native host files')\n    .action(async () => {\n    try {\n        console.log((0, utils_1.colorText)('Fixing execution permissions...', 'blue'));\n        await (0, utils_1.ensureExecutionPermissions)();\n        console.log((0, utils_1.colorText)('✓ Execution permissions fixed successfully!', 'green'));\n    }\n    catch (error) {\n        console.error((0, utils_1.colorText)(`Failed to fix permissions: ${error.message}`, 'red'));\n        process.exit(1);\n    }\n});\n// Update port in stdio-config.json\ncommander_1.program\n    .command('update-port <port>')\n    .description('Update the port number in stdio-config.json')\n    .action(async (port) => {\n    try {\n        const portNumber = parseInt(port, 10);\n        if (isNaN(portNumber) || portNumber < 1 || portNumber > 65535) {\n            console.error((0, utils_1.colorText)('Error: Port must be a valid number between 1 and 65535', 'red'));\n            process.exit(1);\n        }\n        const configPath = path.join(__dirname, 'mcp', 'stdio-config.json');\n        if (!fs.existsSync(configPath)) {\n            console.error((0, utils_1.colorText)(`Error: Configuration file not found at ${configPath}`, 'red'));\n            process.exit(1);\n        }\n        const configData = fs.readFileSync(configPath, 'utf8');\n        const config = JSON.parse(configData);\n        const currentUrl = new URL(config.url);\n        currentUrl.port = portNumber.toString();\n        config.url = currentUrl.toString();\n        fs.writeFileSync(configPath, JSON.stringify(config, null, 4));\n        console.log((0, utils_1.colorText)(`✓ Port updated successfully to ${portNumber}`, 'green'));\n        console.log((0, utils_1.colorText)(`Updated URL: ${config.url}`, 'blue'));\n    }\n    catch (error) {\n        console.error((0, utils_1.colorText)(`Failed to update port: ${error.message}`, 'red'));\n        process.exit(1);\n    }\n});\n// Diagnose installation and environment issues\ncommander_1.program\n    .command('doctor')\n    .description('Diagnose installation and environment issues')\n    .option('--json', 'Output diagnostics as JSON')\n    .option('--fix', 'Attempt to fix common issues automatically')\n    .option('-b, --browser <browser>', 'Target browser (chrome, chromium, or all)')\n    .action(async (options) => {\n    try {\n        const exitCode = await (0, doctor_1.runDoctor)({\n            json: Boolean(options.json),\n            fix: Boolean(options.fix),\n            browser: options.browser,\n        });\n        process.exit(exitCode);\n    }\n    catch (error) {\n        console.error((0, utils_1.colorText)(`Doctor failed: ${error.message}`, 'red'));\n        process.exit(1);\n    }\n});\n// Export diagnostic report for GitHub Issues\ncommander_1.program\n    .command('report')\n    .description('Export a diagnostic report for GitHub Issues')\n    .option('--json', 'Output report as JSON (default: Markdown)')\n    .option('--output <file>', 'Write report to file instead of stdout')\n    .option('--copy', 'Copy report to clipboard')\n    .option('--no-redact', 'Disable redaction of usernames/paths/tokens')\n    .option('--include-logs <mode>', 'Include wrapper logs: none | tail | full', 'tail')\n    .option('--log-lines <n>', 'Lines to include when --include-logs=tail', '200')\n    .option('-b, --browser <browser>', 'Target browser (chrome, chromium, or all)')\n    .action(async (options) => {\n    try {\n        const exitCode = await (0, report_1.runReport)({\n            json: Boolean(options.json),\n            output: options.output,\n            copy: Boolean(options.copy),\n            redact: options.redact,\n            includeLogs: options.includeLogs,\n            logLines: options.logLines ? parseInt(options.logLines, 10) : undefined,\n            browser: options.browser,\n        });\n        process.exit(exitCode);\n    }\n    catch (error) {\n        console.error((0, utils_1.colorText)(`Report failed: ${error.message}`, 'red'));\n        process.exit(1);\n    }\n});\ncommander_1.program.parse(process.argv);\n// If no command provided, show help\nif (!process.argv.slice(2).length) {\n    commander_1.program.outputHelp();\n}\n//# sourceMappingURL=cli.js.map"}],"structuredContent":{"result":"[task:ee2b71378fdb] #!/usr/bin/env node\n\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commander_1 = require(\"commander\");\nconst fs = __importStar(require(\"fs\"));\nconst path = __importStar(require(\"path\"));\nconst utils_1 = require(\"./scripts/utils\");\nconst browser_config_1 = require(\"./scripts/browser-config\");\nconst doctor_1 = require(\"./scripts/doctor\");\nconst report_1 = require(\"./scripts/report\");\ncommander_1.program\n    .version(require('../package.json').version)\n    .description('Mcp Chrome Bridge - Local service for communicating with Chrome extension');\n// Register Native Messaging host\ncommander_1.program\n    .command('register')\n    .description('Register Native Messaging host')\n    .option('-f, --force', 'Force re-registration')\n    .option('-s, --system', 'Use system-level installation (requires administrator/sudo privileges)')\n    .option('-b, --browser <browser>', 'Register for specific browser (chrome, chromium, or all)')\n    .option('-d, --detect', 'Auto-detect installed browsers')\n    .action(async (options) => {\n    try {\n        // Write Node.js path for run_host scripts\n        (0, utils_1.writeNodePathFile)(__dirname);\n        // Determine which browsers to register\n        let targetBrowsers;\n        if (options.browser) {\n            if (options.browser.toLowerCase() === 'all') {\n                targetBrowsers = [browser_config_1.BrowserType.CHROME, browser_config_1.BrowserType.CHROMIUM];\n                console.log((0, utils_1.colorText)('Registering for all supported browsers...', 'blue'));\n            }\n            else {\n                const browserType = (0, browser_config_1.parseBrowserType)(options.browser);\n                if (!browserType) {\n                    console.error((0, utils_1.colorText)(`Invalid browser: ${options.browser}. Use 'chrome', 'chromium', or 'all'`, 'red'));\n                    process.exit(1);\n                }\n                targetBrowsers = [browserType];\n            }\n        }\n        else if (options.detect) {\n            targetBrowsers = (0, browser_config_1.detectInstalledBrowsers)();\n            if (targetBrowsers.length === 0) {\n                console.log((0, utils_1.colorText)('No supported browsers detected, will register for Chrome and Chromium', 'yellow'));\n                targetBrowsers = undefined; // Will use default behavior\n            }\n        }\n        // If neither option specified, tryRegisterUserLevelHost will detect browsers\n        // Detect if running with root/administrator privileges\n        const isRoot = process.getuid && process.getuid() === 0; // Unix/Linux/Mac\n        let isAdmin = false;\n        if (process.platform === 'win32') {\n            try {\n                isAdmin = require('is-admin')(); // Windows requires additional package\n            }\n            catch (error) {\n                console.warn((0, utils_1.colorText)('Warning: Unable to detect administrator privileges on Windows', 'yellow'));\n                isAdmin = false;\n            }\n        }\n        const hasElevatedPermissions = isRoot || isAdmin;\n        // If --system option is specified or running with root/administrator privileges\n        if (options.system || hasElevatedPermissions) {\n            // TODO: Update registerWithElevatedPermissions to support multiple browsers\n            await (0, utils_1.registerWithElevatedPermissions)();\n            console.log((0, utils_1.colorText)('System-level Native Messaging host registered successfully!', 'green'));\n            console.log((0, utils_1.colorText)('You can now use connectNative in Chrome extension to connect to this service.', 'blue'));\n        }\n        else {\n            // Regular user-level installation\n            console.log((0, utils_1.colorText)('Registering user-level Native Messaging host...', 'blue'));\n            const success = await (0, utils_1.tryRegisterUserLevelHost)(targetBrowsers);\n            if (success) {\n                console.log((0, utils_1.colorText)('Native Messaging host registered successfully!', 'green'));\n                console.log((0, utils_1.colorText)('You can now use connectNative in Chrome extension to connect to this service.', 'blue'));\n            }\n            else {\n                console.log((0, utils_1.colorText)('User-level registration failed, please try the following methods:', 'yellow'));\n                console.log((0, utils_1.colorText)('  1. sudo mcp-chrome-bridge register', 'yellow'));\n                console.log((0, utils_1.colorText)('  2. mcp-chrome-bridge register --system', 'yellow'));\n                process.exit(1);\n            }\n        }\n    }\n    catch (error) {\n        console.error((0, utils_1.colorText)(`Registration failed: ${error.message}`, 'red'));\n        process.exit(1);\n    }\n});\n// Fix execution permissions\ncommander_1.program\n    .command('fix-permissions')\n    .description('Fix execution permissions for native host files')\n    .action(async () => {\n    try {\n        console.log((0, utils_1.colorText)('Fixing execution permissions...', 'blue'));\n        await (0, utils_1.ensureExecutionPermissions)();\n        console.log((0, utils_1.colorText)('✓ Execution permissions fixed successfully!', 'green'));\n    }\n    catch (error) {\n        console.error((0, utils_1.colorText)(`Failed to fix permissions: ${error.message}`, 'red'));\n        process.exit(1);\n    }\n});\n// Update port in stdio-config.json\ncommander_1.program\n    .command('update-port <port>')\n    .description('Update the port number in stdio-config.json')\n    .action(async (port) => {\n    try {\n        const portNumber = parseInt(port, 10);\n        if (isNaN(portNumber) || portNumber < 1 || portNumber > 65535) {\n            console.error((0, utils_1.colorText)('Error: Port must be a valid number between 1 and 65535', 'red'));\n            process.exit(1);\n        }\n        const configPath = path.join(__dirname, 'mcp', 'stdio-config.json');\n        if (!fs.existsSync(configPath)) {\n            console.error((0, utils_1.colorText)(`Error: Configuration file not found at ${configPath}`, 'red'));\n            process.exit(1);\n        }\n        const configData = fs.readFileSync(configPath, 'utf8');\n        const config = JSON.parse(configData);\n        const currentUrl = new URL(config.url);\n        currentUrl.port = portNumber.toString();\n        config.url = currentUrl.toString();\n        fs.writeFileSync(configPath, JSON.stringify(config, null, 4));\n        console.log((0, utils_1.colorText)(`✓ Port updated successfully to ${portNumber}`, 'green'));\n        console.log((0, utils_1.colorText)(`Updated URL: ${config.url}`, 'blue'));\n    }\n    catch (error) {\n        console.error((0, utils_1.colorText)(`Failed to update port: ${error.message}`, 'red'));\n        process.exit(1);\n    }\n});\n// Diagnose installation and environment issues\ncommander_1.program\n    .command('doctor')\n    .description('Diagnose installation and environment issues')\n    .option('--json', 'Output diagnostics as JSON')\n    .option('--fix', 'Attempt to fix common issues automatically')\n    .option('-b, --browser <browser>', 'Target browser (chrome, chromium, or all)')\n    .action(async (options) => {\n    try {\n        const exitCode = await (0, doctor_1.runDoctor)({\n            json: Boolean(options.json),\n            fix: Boolean(options.fix),\n            browser: options.browser,\n        });\n        process.exit(exitCode);\n    }\n    catch (error) {\n        console.error((0, utils_1.colorText)(`Doctor failed: ${error.message}`, 'red'));\n        process.exit(1);\n    }\n});\n// Export diagnostic report for GitHub Issues\ncommander_1.program\n    .command('report')\n    .description('Export a diagnostic report for GitHub Issues')\n    .option('--json', 'Output report as JSON (default: Markdown)')\n    .option('--output <file>', 'Write report to file instead of stdout')\n    .option('--copy', 'Copy report to clipboard')\n    .option('--no-redact', 'Disable redaction of usernames/paths/tokens')\n    .option('--include-logs <mode>', 'Include wrapper logs: none | tail | full', 'tail')\n    .option('--log-lines <n>', 'Lines to include when --include-logs=tail', '200')\n    .option('-b, --browser <browser>', 'Target browser (chrome, chromium, or all)')\n    .action(async (options) => {\n    try {\n        const exitCode = await (0, report_1.runReport)({\n            json: Boolean(options.json),\n            output: options.output,\n            copy: Boolean(options.copy),\n            redact: options.redact,\n            includeLogs: options.includeLogs,\n            logLines: options.logLines ? parseInt(options.logLines, 10) : undefined,\n            browser: options.browser,\n        });\n        process.exit(exitCode);\n    }\n    catch (error) {\n        console.error((0, utils_1.colorText)(`Report failed: ${error.message}`, 'red'));\n        process.exit(1);\n    }\n});\ncommander_1.program.parse(process.argv);\n// If no command provided, show help\nif (!process.argv.slice(2).length) {\n    commander_1.program.outputHelp();\n}\n//# sourceMappingURL=cli.js.map"},"isError":false}}

